# 并发编程最新2021年面试题附答案解析，大汇总

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://github.com/souyunku/DevBooks/blob/master/docs/index.md)



### 1、JVM怎么判断一个对象是不是要回收？

引用计数法（缺点是对于相互引用的对象，无法进行清除） 可达性分析


### 2、Java中用到的线程调度算法是什么

抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。


### 3、方法区溢出的原因？

方法区主要存放类型信息，如类名、访问修饰符、常量池、字段描述、方法描述等。只要不断在运行时产生大量类，方法区就会溢出。例如使用 JDK 反射或 CGLib 直接操作字节码在运行时生成大量的类。很多框架如 Spring、Hibernate 等对类增强时都会使用 CGLib 这类字节码技术，增强的类越多就需要越大的方法区保证动态生成的新类型可以载入内存，也就更容易导致方法区溢出。

JDK8 使用元空间取代永久代，HotSpot 提供了一些参数作为元空间防御措施，例如 `-XX:MetaspaceSize` 指定元空间初始大小，达到该值会触发 GC 进行类型卸载，同时收集器会对该值进行调整，如果释放大量空间就适当降低该值，如果释放很少空间就适当提高。


### 4、GC 垃圾收集器

Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器， JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器


### 5、线程池四种创建方式？

**Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：**

**1、**  newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

**2、**  newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

**3、**  newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。

**4、**  newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。


### 6、列举一些你知道的打破双亲委派机制的例子。为什么要打破？

**1、** JNDI 通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类加载器完成类加载的行为。打破的原因，是为了 JNDI 服务的类加载器是启动器类加载，为了完成高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。

**2、** Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。打破的目的是为了完成应用间的类隔离。

**3、** OSGi，实现模块化热部署，为每个模块都自定义了类加载器，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有平级的类加载器加载行为。打破的原因是为了实现模块热替换。

**4、** JDK 9，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。打破的原因，是为了添加模块化的特性。


### 7、同步方法和同步块，哪个是更好的选择？

同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。

同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。


### 8、JVM有哪些内存区域？(JVM的内存布局是什么？)

JVM包含`堆`、`元空间`、`Java虚拟机栈`、`本地方法栈`、`程序计数器`等内存区域。其中，堆是占用内存最大的一块。我们平常的`-Xmx`、`-Xms`等参数，就是针对于堆进行设计的。

**1、** 堆：JVM堆中的数据，是共享的，是占用内存最大的一块区域

**2、** 虚拟机栈：Java虚拟机栈，是基于线程的，用来服务字节码指令的运行

**3、** 程序计数器：当前线程所执行的字节码的行号指示器

**4、** 元空间：方法区就在这里，非堆本地内存：其他的内存占用空间


### 9、什么是ThreadLocal变量？

ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。


### 10、java中有几种方法可以实现一个线程？

继承 Thread 类

实现 Runnable 接口

实现 Callable 接口，需要实现的是 call() 方法


### 11、什么情况下会发生栈内存溢出？
### 12、Java 中的同步集合与并发集合有什么区别？
### 13、怎么检测一个线程是否拥有锁？
### 14、同步方法和同步块，哪个是更好的选择?
### 15、什么是阻塞式方法？
### 16、什么是方法内联？
### 17、程序计数器是什么？
### 18、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？
### 19、什么是逃逸分析？
### 20、FutureTask是什么
### 21、对象是怎么从年轻代进入老年代的？
### 22、CAS的问题
### 23、Java 8 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢？
### 24、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
### 25、线程的状态流转图
### 26、多线程的常用方法
### 27、synchronized 和 volatile 的区别是什么？
### 28、多线程同步和互斥有几种实现方法，都是什么？
### 29、说一下堆内存中对象的分配的基本策略
### 30、什么时候会造成堆外内存溢出？
### 31、线程池有什么优点？
### 32、生产环境用的什么JDK？如何配置的垃圾收集器？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)




## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
